{"ast":null,"code":"import { useCallback, useMemo } from 'react';\nimport { useUncontrolled } from '../use-uncontrolled/use-uncontrolled.js';\nimport { range } from '../utils/range/range.js';\nconst DOTS = \"dots\";\n\nfunction usePagination({\n  total,\n  siblings = 1,\n  boundaries = 1,\n  page,\n  initialPage = 1,\n  onChange\n}) {\n  const [activePage, setActivePage] = useUncontrolled({\n    value: page,\n    onChange,\n    defaultValue: initialPage,\n    finalValue: initialPage,\n    rule: _page => typeof _page === \"number\" && _page <= total\n  });\n  const setPage = useCallback(pageNumber => {\n    if (pageNumber <= 0) {\n      setActivePage(1);\n    } else if (pageNumber > total) {\n      setActivePage(total);\n    } else {\n      setActivePage(pageNumber);\n    }\n  }, [total]);\n\n  const next = () => setPage(activePage + 1);\n\n  const previous = () => setPage(activePage - 1);\n\n  const first = () => setPage(1);\n\n  const last = () => setPage(total);\n\n  const paginationRange = useMemo(() => {\n    const totalPageNumbers = siblings * 2 + 3 + boundaries * 2;\n\n    if (totalPageNumbers >= total) {\n      return range(1, total);\n    }\n\n    const leftSiblingIndex = Math.max(activePage - siblings, boundaries);\n    const rightSiblingIndex = Math.min(activePage + siblings, total - boundaries);\n    const shouldShowLeftDots = leftSiblingIndex > boundaries + 2;\n    const shouldShowRightDots = rightSiblingIndex < total - (boundaries + 1);\n\n    if (!shouldShowLeftDots && shouldShowRightDots) {\n      const leftItemCount = siblings * 2 + boundaries + 2;\n      return [...range(1, leftItemCount), DOTS, ...range(total - (boundaries - 1), total)];\n    }\n\n    if (shouldShowLeftDots && !shouldShowRightDots) {\n      const rightItemCount = boundaries + 1 + 2 * siblings;\n      return [...range(1, boundaries), DOTS, ...range(total - rightItemCount, total)];\n    }\n\n    return [...range(1, boundaries), DOTS, ...range(leftSiblingIndex, rightSiblingIndex), DOTS, ...range(total - boundaries + 1, total)];\n  }, [total, siblings, activePage]);\n  return {\n    range: paginationRange,\n    active: activePage,\n    setPage,\n    next,\n    previous,\n    first,\n    last\n  };\n}\n\nexport { DOTS, usePagination };","map":{"version":3,"sources":["../../src/use-pagination/use-pagination.ts"],"names":[],"mappings":"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","sourcesContent":["import { useMemo, useCallback } from 'react';\nimport { useUncontrolled } from '../use-uncontrolled/use-uncontrolled';\nimport { range } from '../utils';\n\nexport const DOTS = 'dots';\n\nexport interface PaginationParams {\n  /** Page selected on initial render, defaults to 1 */\n  initialPage?: number;\n\n  /** Controlled active page number */\n  page?: number;\n\n  /** Total amount of pages */\n  total: number;\n\n  /** Siblings amount on left/right side of selected page, defaults to 1 */\n  siblings?: number;\n\n  /** Amount of elements visible on left/right edges, defaults to 1  */\n  boundaries?: number;\n\n  /** Callback fired after change of each page */\n  onChange?: (page: number) => void;\n}\n\nexport function usePagination({\n  total,\n  siblings = 1,\n  boundaries = 1,\n  page,\n  initialPage = 1,\n  onChange,\n}: PaginationParams) {\n  const [activePage, setActivePage] = useUncontrolled({\n    value: page,\n    onChange,\n    defaultValue: initialPage,\n    finalValue: initialPage,\n    rule: (_page) => typeof _page === 'number' && _page <= total,\n  });\n\n  const setPage = useCallback(\n    (pageNumber: number) => {\n      if (pageNumber <= 0) {\n        setActivePage(1);\n      } else if (pageNumber > total) {\n        setActivePage(total);\n      } else {\n        setActivePage(pageNumber);\n      }\n    },\n    [total]\n  );\n\n  const next = () => setPage(activePage + 1);\n  const previous = () => setPage(activePage - 1);\n  const first = () => setPage(1);\n  const last = () => setPage(total);\n\n  const paginationRange = useMemo((): (number | 'dots')[] => {\n    // Pages count is determined as siblings (left/right) + boundaries(left/right) + currentPage + 2*DOTS\n    const totalPageNumbers = siblings * 2 + 3 + boundaries * 2;\n\n    /*\n     * If the number of pages is less than the page numbers we want to show in our\n     * paginationComponent, we return the range [1..total]\n     */\n    if (totalPageNumbers >= total) {\n      return range(1, total);\n    }\n\n    const leftSiblingIndex = Math.max(activePage - siblings, boundaries);\n    const rightSiblingIndex = Math.min(activePage + siblings, total - boundaries);\n\n    /*\n     * We do not want to show dots if there is only one position left\n     * after/before the left/right page count as that would lead to a change if our Pagination\n     * component size which we do not want\n     */\n    const shouldShowLeftDots = leftSiblingIndex > boundaries + 2;\n    const shouldShowRightDots = rightSiblingIndex < total - (boundaries + 1);\n\n    if (!shouldShowLeftDots && shouldShowRightDots) {\n      const leftItemCount = siblings * 2 + boundaries + 2;\n      return [...range(1, leftItemCount), DOTS, ...range(total - (boundaries - 1), total)];\n    }\n\n    if (shouldShowLeftDots && !shouldShowRightDots) {\n      const rightItemCount = boundaries + 1 + 2 * siblings;\n      return [...range(1, boundaries), DOTS, ...range(total - rightItemCount, total)];\n    }\n\n    return [\n      ...range(1, boundaries),\n      DOTS,\n      ...range(leftSiblingIndex, rightSiblingIndex),\n      DOTS,\n      ...range(total - boundaries + 1, total),\n    ];\n  }, [total, siblings, activePage]);\n\n  return {\n    range: paginationRange,\n    active: activePage,\n    setPage,\n    next,\n    previous,\n    first,\n    last,\n  };\n}\n"]},"metadata":{},"sourceType":"module"}